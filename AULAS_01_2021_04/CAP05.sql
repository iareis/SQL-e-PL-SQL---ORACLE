-- MULTIPLAS TABELAS
-- JOINS

SELECT * FROM TALUNO;

SELECT * FROM TCONTRATO;

-- ALGUMAS ALTERAÇÕES NO BANCO DE DADOS 
-- INSERT PARA INSERIR DADOS
-- UPDATE PARA ALTERAR DADOS
INSERT INTO TALUNO VALUES (21, 'NULL', 'TORRES', 95560000, 'RS', 2350, '12/05/1979');
INSERT INTO TALUNO VALUES (22, 'ALBERTO', 'CURITIBA', 81050360, 'PR', 2120, '14/07/1981');
INSERT INTO TALUNO VALUES (23, 'BEATRIZ', 'VITÓRIA', 29000000, 'ES', 4350, '16/09/1984');
INSERT INTO TALUNO VALUES (24, 'CLODOALDO', 'BELO HORIZONTE', 31630900, 'MG', 7350, '18/11/1986');
INSERT INTO TALUNO VALUES (31, 'DAMARIS', 'CAMPO GRANDE', 79002190, 'MS', 2820, '20/01/1988');
INSERT INTO TALUNO VALUES (32, 'EVERTON', 'MANAUS', 69030418, 'AM', 5280, '22/03/1990');
INSERT INTO TALUNO VALUES (35, 'FABÍULA', 'RIO BRANCO', 69908440, 'AC', 1370, '24/04/1992');

UPDATE TALUNO SET 
CEP = 93320970,
ESTADO = 'RS'
WHERE COD_ALUNO = 1;

/* 
UPDATE TALUNO SET 
CEP = 89163413,
ESTADO ='RS'
WHERE COD_ALUNO = 2
AND COD_ALUNO = 10
AND COD_ALUNO = 12
AND COD_ALUNO = 13
AND COD_ALUNO = 15;
-- ACIMA MINHA TENTATIVA DE ALTERAR VÁRIAS ROWS DE UMA VEZ

-- ABAIXO DUAS FORMAS DE VÁRIAS ATUALIZAÇÕES, PORÉM AINDA NÃO VI ESTE ASSUNTO COMPLETAMENTE
UPDATE config
   SET config_value = CASE config_name 
                      WHEN 'name1' THEN 'value' 
                      WHEN 'name2' THEN 'value2' 
                      ELSE config_value
                      END
 WHERE config_name IN('name1', 'name2');

 INSERT INTO mytable (id, a, b, c)
VALUES (1, 'a1', 'b1', 'c1'),
(2, 'a2', 'b2', 'c2'),
(3, 'a3', 'b3', 'c3'),
(4, 'a4', 'b4', 'c4'),
(5, 'a5', 'b5', 'c5'),
(6, 'a6', 'b6', 'c6')
ON DUPLICATE KEY UPDATE id=VALUES(id),
a=VALUES(a),
b=VALUES(b),
c=VALUES(c);
*/

UPDATE TALUNO SET 
CEP = 89163413,
ESTADO ='RS'
WHERE COD_ALUNO = 2
or COD_ALUNO = 10
or COD_ALUNO = 12
or COD_ALUNO = 13
or COD_ALUNO = 15;
-- se usar o and ele só vai alterar a row que tiver o cod_aluno igual a todos os números que você colocou


UPDATE TALUNO SET 
CEP = 93800012
WHERE COD_ALUNO =3;

UPDATE TALUNO SET 
CEP = 90020180,
ESTADO = 'RS'
WHERE COD_ALUNO = 5
OR COD_ALUNO = 17;

UPDATE TALUNO SET 
CEP = 88701970,
ESTADO ='SC'
WHERE COD_ALUNO = 11;

UPDATE TALUNO SET 
CEP = 69908440, 
ESTADO = 'AC'
WHERE COD_ALUNO = 13;

UPDATE TALUNO SET 
CEP = 88034101,
ESTADO = 'SC'
WHERE COD_ALUNO = 8
OR COD_ALUNO = 12
OR COD_ALUNO = 14;

UPDATE TALUNO SET 
CEP = 40015970,
ESTADO ='BA'
WHERE COD_ALUNO = 16;

UPDATE TALUNO SET 
CIDADE = 'ARAGUAINA',
CEP = 77818635,
ESTADO = 'AC'
WHERE COD_ALUNO = 18;

UPDATE TALUNO SET 
CEP = 98345000,
ESTADO = 'RS'
WHERE COD_ALUNO = 20;

UPDATE TALUNO SET 
CEP = 93950000,
ESTADO = 'RS'
WHERE COD_ALUNO = 6;

UPDATE TALUNO SET 
CEP = 99720000,
ESTADO = 'RS'
WHERE COD_ALUNO = 7;

INSERT INTO TALUNO VALUES (35, 'JEFERSON', 'RIO DE JANEIRO', 23548168, 'RJ', 14300, '26/06/1968');
INSERT INTO TALUNO VALUES (35, 'KAREN', 'ANGRA DOS REIS', 23900050, 'AC', 1370, '28/08/1994');

UPDATE TALUNO SET 
ESTADO = 'RJ'
WHERE COD_ALUNO = 37;

SELECT * FROM TALUNO;

-- PRIMEIRO UM SELECT ERRADO PARA MOSTRAR
-- A FORMAÇÃO DE UM PLANO CARTESIANO

SELECT TALUNO.COD_ALUNO, TALUNO.NOME, TCONTRATO.TOTAL
FROM TALUNO, TCONTRATO;
/* O ERRO É A FALTA É O CRITÉRIO DE UNIÃO ENTRE AS TABELAS */

-- AGORA DE FORMA CORRETA

SELECT TALUNO.COD_ALUNO, TALUNO.NOME, TCONTRATO.TOTAL
FROM TALUNO, TCONTRATO
WHERE TALUNO.COD_ALUNO = TCONTRATO.COD_ALUNO;

--ERRO - COLUNA AMBIGUA

SELECT COD_ALUNO, TALUNO.NOME, TCONTRATO.TOTAL
FROM TALUNO, TCONTRATO
WHERE TALUNO.COD_ALUNO = TCONTRATO.COD_ALUNO;

SELECT TALUNO.COD_ALUNO, TALUNO.NOME, TCONTRATO.TOTAL
FROM TALUNO, TCONTRATO
WHERE TALUNO.COD_ALUNO = COD_ALUNO;
/*quando existe uma coluna comum em duas ou mais tabelas e não ESPECIFICAMOS
a tabela fica ERRADO devido a ser uma TABELA AMBÍGUA*/

-- UNIÃO DA TABELA DE ALUNOS COM CONTRATOS

SELECT ALU.COD_ALUNO, ALU.NOME AS ALUNO,
       CON.COD_CONTRATO, CON.DATA, CON.TOTAL
FROM TALUNO ALU, TCONTRATO CON 
WHERE CON.COD_ALUNO = ALU.COD_ALUNO
AND UPPER(ALU.NOME) LIKE '%'
ORDER BY ALU.NOME; 

--

SELECT * FROM TALUNO;

SELECT * FROM TCONTRATO;

SELECT * FROM TITEM;

SELECT * FROM TCURSO;

--

SELECT  ALU.COD_ALUNO, ALU.NOME AS ALUNO,
        CON.COD_CONTRATO, CON.DATA, CON.TOTAL,
        ITE.COD_CURSO, CUR.NOME AS CURSO,
        ITE.VALOR
FROM TALUNO ALU, TCONTRATO CON, TITEM ITE, TCURSO CUR 
WHERE   ALU.COD_ALUNO = CON.COD_ALUNO
AND     CON.COD_CONTRATO = ITE.COD_CONTRATO
AND     ITE.COD_CURSO = CUR.COD_CURSO
ORDER BY CON.TOTAL DESC;

-- QUERENDO QUE APAREÇÃO TODOS OS ALUNOS, INCLUINDO OS QUE NÃO POSSUEM
-- CONTRATOS E/OU CURSOS, DEVE COLOCAR (+) NOS CRITERIOS DE UNIÃO

SELECT  ALU.COD_ALUNO, ALU.NOME AS ALUNO,
        CON.COD_CONTRATO, CON.DATA, CON.TOTAL,
        ITE.COD_CURSO, CUR.NOME AS CURSO,
        ITE.VALOR
FROM TALUNO ALU, TCONTRATO CON, TITEM ITE, TCURSO CUR 
WHERE   ALU.COD_ALUNO = CON.COD_ALUNO(+)
AND     CON.COD_CONTRATO = ITE.COD_CONTRATO(+)
AND     ITE.COD_CURSO = CUR.COD_CURSO(+)
ORDER BY CON.TOTAL DESC;

-- CRIANDO UMA NOVA TABELA COM FAIXAS DE DESCONTOS

CREATE TABLE TDESCONTO
(
    CLASSE VARCHAR(1) PRIMARY KEY,
    INFERIOR NUMBER(4,2),
    SUPERIOR NUMBER(4,2)
);

INSERT INTO TDESCONTO VALUES ('A',00,10);
INSERT INTO TDESCONTO VALUES ('B',11,15);
INSERT INTO TDESCONTO VALUES ('C',16,20);
INSERT INTO TDESCONTO VALUES ('D',21,25);
INSERT INTO TDESCONTO VALUES ('E',26,30);

SELECT * FROM TDESCONTO;

COMMIT;

-- ALGUMAS ALTERAÇÕES PARA A TABELA FICAR IGUAL A DA AULA

UPDATE TCONTRATO SET 
TOTAL = 500,
DESCONTO = 10
WHERE COD_CONTRATO = 1;

UPDATE TCONTRATO SET 
TOTAL = 750,
DESCONTO = 20
WHERE COD_CONTRATO = 2;

UPDATE TCONTRATO SET 
TOTAL = 1500,
DESCONTO = 5
WHERE COD_CONTRATO = 3;

UPDATE TCONTRATO SET 
TOTAL = 1600,
DESCONTO = 10
WHERE COD_CONTRATO = 4;

UPDATE TCONTRATO SET 
TOTAL = 800,
DESCONTO = 18
WHERE COD_CONTRATO = 5;

UPDATE TCONTRATO SET 
TOTAL = 445,
DESCONTO = 27
WHERE COD_CONTRATO = 6;

UPDATE TCONTRATO SET 
TOTAL = 445,
DESCONTO = 20
WHERE COD_CONTRATO = 7;

-- 

SELECT * FROM TCONTRATO;

-- 

SELECT  CON.COD_CONTRATO AS CONTRATO,
        DES.CLASSE AS DESCONTO
FROM    TCONTRATO CON, TDESCONTO DES 
WHERE   NVL(CON.DESCONTO,0)  BETWEEN DES.INFERIOR AND DES.SUPERIOR
-- lembrando que o NVL utilizado para substituir null por algo. neste exemplo, por ZERO
ORDER BY CON.COD_CONTRATO;

SELECT * FROM TCURSO;

-- MOSTRAR OS CURSOS VENDIDOS

SELECT CUR.COD_CURSO, CUR.NOME, ITE.VALOR
FROM TCURSO CUR, TITEM ITE
WHERE CUR.COD_CURSO = ITE.COD_CURSO

-- MOSTRAR OS CURSOS NÃO VENDIDOS

SELECT CUR.COD_CURSO, CUR.NOME, ITE.COD_ITEM
FROM TCURSO CUR, TITEM ITE 
WHERE CUR.COD_CURSO = ITE.COD_CURSO(+)
-- até a linha acima mostra todos os cursos vendidos e o (+) faz aparecer os não vendidos
AND ITE.COD_ITEM IS NULL;
-- ao incluir a linha acima, ele filtra apenas os NULL que são os não vendidos

-- ADICIONAR COLUNA EM UMA TABELA
ALTER TABLE TCURSO ADD PRE_REQ INTEGER;
/*apenas relembrando*/

UPDATE TCURSO SET
PRE_REQ = 7
WHERE COD_CURSO = 1;

UPDATE TCURSO SET
PRE_REQ = 7
WHERE COD_CURSO = 3;

UPDATE TCURSO SET
PRE_REQ = 1
WHERE COD_CURSO = 2;

UPDATE TCURSO SET
PRE_REQ = 3
WHERE COD_CURSO = 4;

-- SELECT DE DUAS TABELAS (sendo a mesma tabela)

SELECT  CURSO.NOME AS CURSO,
        PRE_REQ.NOME AS PRE_REQUISITO
FROM    TCURSO CURSO, TCURSO PRE_REQ
WHERE   CURSO.PRE_REQ = PRE_REQ.COD_CURSO(+);




